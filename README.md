RabbitDB
========

A simple abstraction of data access. Simple, feature-rich, clean and hopefully efficent. 
Works like to conjure a white rabbit out of a hat  :)

Simple
----------
No dynamics, simple and no obscure command execution. 
If used by convention - no attributes are needed.

Clean
-----
Based on clean-code and SOLID principles.

Features
------------
Change tracking, identity map, multiple resultsets, custom mappings
(all on request - soon to come).
Seperate `Entity` class to inherit from. This way you are not forced to work with `DbSession`.

```csharp
[Table("Posts")]
class Post : Entity
{
    [Column("Id", DbType = DbType.Int32, AutoGenerated = true)]
    public int Id { get; set; }
    public int AuthorId { get; set; }
    public string Title { get; set; }
    public DateTime CreatedOn { get; set; }
    public PostType Type { get; set; }
    public int? TopicId { get; set; }
    public bool IsActive { get; set; }
}
```
Let´s assume you want to use an other primary key then `ID`:
```csharp
[Table("Posts", AlternativePKs="FirstID, SecondID")]
class Post
{
    public int Id { get; set; }
    public string FirstID { get; set; }
    public int SecondID { get; set; }
}
```
If you decide to use alternative primary keys the default primary key will be ignored!!
And like you can see, you don´t have to use `Entity` class. You can use your own POCOs.

If you name your class like your table and your properties like your columns you don´t need attributes *at all*.
All needed information like name of table, name of column, dbtype, primarykey(s), default value, nullable is gathered by RabbitDB for you.

Loading data for entity:
```csharp
post.Id = 6;
post.Load();
```
Update entity (changes made to entity are tracked by RabbitDB for you). 
So if you change AuthorId to an other value then the one which was loaded, RabbitDB tracks this change and
executes an update command by calling `PersistChanges()` on the entity.
```csharp
var post = new Post();
post.Id = 6;
post.Load();

post.AuthorId = 444
post.PersistChanges();
```

Deletion:
```csharp
var post = new Post();
post.Id = 6;
post.MarkForDeletion();
post.PersistChanges();
```

If you decide to inherit from `Entity` you have to register your connection string and the used DbEngine.
```csharp
Registrar<string>.Register("Company.Module.*", @"YourConnectionString");
Registrar<DbEngine>.Register("Company.Module.*", DbEngine.SqlServer);
```
You can of cource work with a `EntityCollection` and do what whatever you can do with `Entity`:
```csharp
EntityCollection<Post> postCollection = new EntityCollection<Post>();
postCollection.LoadAll();
Post post = postCollection.FindByKey(16);
post.MarkForDeletion();
Post post2 = postCollection.FindByKey(1);
post2.Title = "New Title";
postCollection.PersistChanges();

// Or for faster deletion of all entities in collection
postCollection.DeleteAll();
```

To avoid change tracking in `EntityCollection` and `Entity` (just for data loading):
```csharp
DbSession.Configuration.AutoDetectChangesEnabled = false; // for disabling change tracking
```
What if you want to be notified if an entity has been inserted, deleted or updated:
```csharp
EntityCollection<Post> collection = new EntityCollection<Post>();
collection.LoadAll();
foreach (Post post in collection)
{
    post.EntityUpdated += (s, e) => { ... ; };
    post.EntityDeleted += (s, e) => { ... ; };
    post.EntityInserted += (s, e) => { ... ; };
}

Post post1 = collection.FindByKey(4);
post1.Title = "Design Patterns";
post1.PersistChanges(); // will raise EntityUpdated event
```

Let´s start using `DbSession`
```csharp
using (DbSession dbSession = new DbSession(@"YourConnectionString", DbEngine.MySql))
{
    ...
}

using (DbSession dbSession = new DbSession(@"YourConnectionString")) // SqlServer by default
{
    ...
}

using (DbSession dbSession = new DbSession(typeof(this))) // uses registered connection string and DbEngine for types namespace.
{
    ...
}
```
Self-explanatory command executions:
```csharp
var scalarValue = dbSession.GetScalarValue<int>("SELECT ProductID FROM Products WHERE Name=@name", new { name = "Herbie" });

dbSsession.ExecuteCommand("UPDATE Posts SET IsActive=@0 WHERE Title=@1 and Id=@2", true, "Mark", 3);

// gets all table entries.
var entitySet = dbSession.GetEntitySet<Post>();

var entitySet = dbSession.GetEntitySet<Post>("SELECT * FROM Posts WHERE Title=@title OR Id=@id", new { title = "Mark", id = 5 });

// the same but without anonymous arguments
var entitySet = dbSession.GetEntitySet<Post>("SELECT * FROM Posts WHERE Title=@0 OR Id=@1", "Mark", 5);

// select your data by using lambda expressions.
var entitySet = dbSsession.GetEntitySet<Post>(post => post.Id == 4 || post.IsActive);
 
// gets the post with primary key '6'
var entity = dbSession.GetEntity<Post>(6);

// gets all posts which fulfill this lambda expression criteria
var entity = dbSession.GetEntity<Post>(post => post.Title == "Mark" && post.Id == 6); 
// Custom specific constants (DateTime, etc.)
var entity = dbSession.GetEntity<Post>(post => post.CreatedOn >= DateTime.Now);

// gets a single value
var value = dbSession.GetValue<int>("SELECT COUNT(*) FROM Posts");

// gets a set of values
var titles = dbSession.GetEntitySet<string>("SELECT Title FROM Posts");

// Multiple results - no problem
var sql = @"SELECT * FROM Posts;
            SELECT * FROM Users;";

var multiSet = dbSession.ExecuteMultiple(sql);
var posts = multiSet.Read<Post>();
var users = multiSet.Read<Users>();
```
Stored procedures:
```csharp
dbSession.ExecuteStoredProcedure("yourStoredProcedureName", new { pParam1 = "Fred", pParam2 = PostType.Page });

// or to receive your poce with a stored procedure
YourPOCO poco = dbSession.ExecuteStoredProcedure<YourPOCO>("yourStoredProcedureName", new { pParam1 = "Fred", pParam2 = PostType.Page });
```
Or if you have a stored procedure with a lot of parameters:
```csharp
public class ExampleProcedure : SqlStoredProcedure
{
    public ExampleProcedure()
        : base("yourStoredProcedureNameHere") { }

    public string TicketID
    {
        get { return base.GetParameterValue<string>("@pTicketID"); }
        set { base.AddParameter("@pTicketID", value, DbType.AnsiString, 255); }
    }
}

// Any where else

ExampleProcedure procedure = new ExampleProcedure();
procedure.TicketID = "TicketID_To_Work_With";
procedure.Execute();
```
Or within a `DbSession`:
```csharp
using (DbSession dbSession = new DbSession("YourConnectionStringHere", DbEngine.SqlServer))
{
    ExampleProcedure procedure = new ExampleProcedure();
    procedure.TicketID = "TicketID_To_Work_With";
    dbSession.ExecuteStoredProcedure(procedure);
}
```
Custom mappings for `Entity`:
```csharp

Registrar<DbEngine>.Register("RabbitDB.Program.*", DbEngine.SqlServer);
Registrar<string>.Register("RabbitDB.Program.*", @"YourConnectionStringHere");

var post = new Post();
post.Id = 16;
post.Load(CustomMap);

static void CustomMap(Post entity, IDataReader dataReader)
{
    while (dataReader.Read())
    {
        entity.Id = (int)dataReader["Id"];
        entity.Title = (string)dataReader["Title"];
        entity.AuthorId = (int)dataReader["AuthorId"];
        entity.CreatedOn = (DateTime)dataReader["CreatedOn"];
        entity.IsActive = (bool)dataReader["IsActive"];
        entity.TopicId = (int)dataReader["TopicId"];
        entity.Type = (PostType)dataReader["Type"];
    }
}
```
